   MOV, MOVI: R[a] := ASH(c, b) (*arithmetic shift*)
 | MVN, MVNI: R[a] := -ASH(c, b)
 | ADD, ADDI: R[a] := R[b] + c
 | SUB, SUBI: R[a] := R[b] - c
 | MUL, MULI: R[a] := R[b] * c
 | Div, DIVI: R[a] := R[b] DIV c
 | Mod, MODI: R[a] := R[b] MOD c
 | CMP, CMPI: Z := R[b] = c; N := R[b] < c
 | CHKI: IF (R[a] < 0) OR (R[a] >= c) THEN R[a] := 0 END
 | LDW: R[a] := M[(R[b] + c) DIV 4]
 | LDB: (*not implemented*)
 | POP: R[a] := M[(R[b]) DIV 4]; INC(R[b], c)
 | STW: M[(R[b] + c) DIV 4] := R[a]
 | STB: (*not implemented*)
 | PSH: DEC(R[b], c); M[(R[b]) DIV 4] := R[a]
 | RD: Texts.Scan(in); R[a] := in.i
 | WRD: Texts.Write(W, " "); Texts.WriteInt(W, R[c], 1)
 | WRH: Texts.WriteHex(W, R[c])
 | WRL: Texts.WriteLn(W); Texts.Append(out, W.buf)
 | BEQ: IF Z THEN nxt := R[15] + c*4 END
 | BNE: IF ~Z THEN nxt := R[15] + c*4 END
 | BLT: IF N THEN nxt := R[15] + c*4 END
 | BGE: IF ~N THEN nxt := R[15] + c*4 END
 | BLE: IF Z OR N THEN nxt := R[15] + c*4 END
 | BGT: IF ~Z & ~N THEN nxt := R[15] + c*4 END
 | BR: nxt := R[15] + c*4
 | BSR: nxt := R[15] + c*4; R[14] := R[15] + 4
 | RET: nxt := R[c MOD 10H];
 IF nxt = 0 THEN EXIT END
 END ;
 R[15] := nxt
 END
 END Execute;
 PROCEDURE Load*(VAR code: ARRAY OF LONGINT; len: LONGINT);
 VAR i: INTEGER;
 BEGIN i := 0;
 WHILE i < len DO M[i + ProgOrg DIV 4] := code[i]; INC(i) END
 END Load;
BEGIN Texts.OpenWriter(W)
END RISC.